#pragma once

/*-----------------------------------------
				  PART 1
-----------------------------------------*/
//#define EX_3_1 
/*	■ EX_3_1 입력으로 벡터 위치 변경하기
	 - 2D.cpp 에 전부 코드
*/ 


//#define EX_3_2 
/*	■ 원을 렌더링하는 코드
	 - 2D.cpp
	 - 예전 학원에서 원그리기 실습했었는데, 딱 그코드
*/ 


//#define EX_4_1
/*	■ sin, cos 를 활용하여 하트를 렌더링하는 코드
*	 - 2D.cpp
*	 - 하트 방정식이라고 다양하게 있다 한다.. 물론 공식 이해는 안하고 코드만 쳐서 실습함


*/


//#define EX_4_4
/* ■ 2차원 회전, SRT 순서 적용하여 하트를 그리는 코드
	- 2D.cpp
	- 2차원 회전 (c * x - s * y, s * x + c * y)
	- SRT 순서 적용하여 2D 에서 하트를 렌더링하는 코드
*/


//#define EX_4_5
/*	■ (x, y) <-> (r, Θ) 변환 으로, 사각형을 degree 에 따라 회오리 모양으로 바꾸는 코드
	 - 2D.cpp
	 - Vector2 클래스의 (x, y) <-> (r, Θ) 를 전환하는 함수를 사용
*/


//#define EX_5_1
/*	■ 2차원 메트릭스 연산 ( SRT 에서 S. R ) 하여, 벡터를 수정하는 코드
	 - 2D.CPP
	 - Matrix2x2 클래스를 활용하는 코드
	 - 기존 EX_4_1 을 대부분 복붙하고 ( 내용 거의 동일 ) , 로테이션과 스케일 기능을, Matrix22 의 S , R 을 사용하여
	   hearts 를 그리는 벡터들을 메트릭스 연산으로 수정하는 코드입니다.
*/


//#define EX_5_2
/*	■ S R T (T는 아핀공간이 아닌, 전단변환행렬로, T 가 아닌 X 좌표 원점 기준 스케일링에 가까움) + INVERSE 
	 - SoftRenderer2D.cpp
	 - 위 EX_5_1 과 유사하지만, S R 에 더해, T(아핀공간이 아니니, 엄밀히는 X좌표 스케일링) 기능을 추가
	  - S, R, T 에 대한 각각의 INVERSE MATRIX를 만들어, 이를 적용하여, 원래 V 과 같은 V을 다시 만드는 작업 추가
	  - 시행 결과의 왼쪽이 SRT 적용 결과. 오른쪽이  SRT -> IS IR IT 적용 결과
*/
























/*-----------------------------------------
				  PART 2
-----------------------------------------*/
//#define EX_6_1
/*	■ EX_6_1
	 - SofRenderer2D.cpp 
	 - 아핀 공간을 사용한 T 를 만들어, SRT  를 사용한 코드. 앞선 EX_5_1 과 내용이 거의 동일하지만, T 에 아핀공간을 사용
	 - SRT 메트릭스들도 3x3 을 처음 사용해보는 코드. 이를 위해 2차 벡터도 3차로 확장했다가, 렌더링 때 다시 2차벡터로 만들어 사용
*/

/* ■ 내장 함수
	- 6장은 아핀공간과, 선그리기(브레젠험 알고리즘) 를 배우는데, 선그리기의 경우 알고리즘이 주기 때문에 코드를 직접 봐야 이해합니다.
	- 강의노트에 적은 수리 내용 외에, 
	 - ScreenPoint.h 의 ToScreenCoordinate, ToCartesianCoordinate 
	 -  WindowsRSI::DrawLine, WindowsRSI::TestRegion, WindowsRSI::CohenSutherlandLineClip
	 
	 위 5개의 함수들을 직접 타이핑해보면서, 이해해야 합니다.


*/


//#define EX_7_1
/*	■ EX_7_1
	 - SoftRenderer2D.cpp
	 - 벡터의 내적으로 코사인(세타) 를 구하여, 물체의 위치가 컨트롤 오브젝트가 바라보는 방향과 얼라인하는지를 계산하는 코드입니다
*/

















/*-----------------------------------------
				  PART 3
-----------------------------------------*/
//#define EX_7_2
/*	■ EX_7_2
	 - SoftRenderer2D.cpp
	 - 백터의 내적으로, 빛의 방향과, 물체가 갖는 방향? 간의 내적으로, 빛에 반사되는 밝기를 계산하는 코드입니다
	 - 위 내적으로 빛의 밝기를 계산하는 코드는 4줄로, 코드의 맨 하단부에 있습니다.
	 - 그외에 내용은 많이 했던 내용들이고, 크게 중요치 않으니, 마지막 코드 4줄만 봐도 무방

*/


//#define EX_7_3
/*	■ EX_7_3
	 - SoftRenderer2D.cpp
	 - 투영행렬 <a, b^> b^ 에 대한 코드입니다. 
	 - 투영행렬을 사용하는 코드는 단 한줄로,		Vector2 projV =  unitV * unitV.Dot(u);  
	 - 따라서 굳이 다시 볼 필요는 없는 코드라 생각됩니다. 
*/


//#define EX_8_1
/*	■ EX_8_1
	 - SoftRenderer2D.cpp
	 - indices (0, 1, 2, 0, 2, 3) 을 사용해서, 준비된 정점 4개로 삼각형 2개를 그리는 코드입니다
	 - indiex 버퍼와 Vertex 버퍼가 어떻게 함께 사용되는지에 대한, 원초적인 모습이기에, 전체적으로 코드를 봐도 좋을 것 같습니다.
*/



//#define EX_8_2
/*	■ EX_8_2
	 - SoftRenderer2D.cpp
	 - 3점의 아핀결합 공식으로, S, T 를 W, U, V 벡터를 통해 도출하여, 0 <= S, T, (1-S-T) <= 1 여부로, 특정 점이 
	   삼각형 내부에 있는지를 판단하여, 삼각형 내부에 색을 칠하는 코드입니다
	 - 연산 효율이 좋아보이지는 않지만, 수리 개념을 바탕으로 도출하기 때문에, 유익하기에, 코드를 전반적으로 모두 보는 것을 추천합니다.
*/


















/*-----------------------------------------
				  PART 4
-----------------------------------------*/
//#define EX_8_3
/*	■ EX_8_3
	 - SoftRenderer2D.cpp
	 - EX_8_2 에서 일부만 수정해서, 강 정점에 할당된 색을, 앞서 아핀결합에서 구한 S, T, (1 - S - T) 를 선형결합하여
	   색을 보간하여 렌더링하는 코드입니다.
	 - EX_8_2 와 더붙어, 실제 엔진에서도 사용되는, 기초가 되는 방법이기 때문에, 전반적으로 코드를 보는 것을 추천합니다.
*/
#define EX_8_4
/*	■ EX_8_4
	 - 
*/